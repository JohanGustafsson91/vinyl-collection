import {
  Fragment,
  lazy,
  Suspense,
  useCallback,
  useEffect,
  useState,
} from "react";
import { FormattedAlbum } from "api/albums";
import { GetServerSideProps, InferGetServerSidePropsType } from "next";
import Head from "next/head";
import styled from "styled-components";
import { breakpoint, breakpointSize, fontSize, space } from "theme";

const loadAlbumComponent = () => import("components/Album/Album");
const Album = lazy(loadAlbumComponent);
import { Cover } from "components/Album/Album.Cover";
import { Filter, FilterOptions } from "components/Filter";

export default function Home({
  syncCollection,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  const [{ status, data: albums }, setState] = useState<{
    status: "pending" | "resolved" | "rejected";
    data: FormattedAlbum[];
  }>({
    status: "pending",
    data: [],
  });

  const [filteredAlbums, setFilteredAlbums] = useState(albums);

  const { width } = useWindowSize();

  useEffect(
    function fetchAlbums() {
      fetch(`/api/albums?syncCollection=${syncCollection}`)
        .then((res) => res.json())
        .then((albums) => {
          loadAlbumComponent();

          return setState({
            status: "resolved",
            data: albums,
          });
        })
        .catch(() =>
          setState({
            status: "rejected",
            data: [],
          })
        );
    },
    [syncCollection]
  );

  useEffect(
    function updateFilteredAlbums() {
      albums.length && setFilteredAlbums(albums);
    },
    [albums]
  );

  const handleFilterAlbums = useCallback(
    ({ query, includeTrack }: FilterOptions) => {
      if (query === "") {
        return setFilteredAlbums(albums);
      }

      const albumsFiltered = albums.filter(function filterAlbum(album) {
        const matchArtist = album.artist
          .toLowerCase()
          .includes(query.toLowerCase());

        const matchTitle = album.title
          .toLowerCase()
          .includes(query.toLowerCase());

        const matchTrack = includeTrack
          ? album.tracks.some(function textIncludesString(track) {
              return track.title.toLowerCase().includes(query.toLowerCase());
            })
          : false;

        return [matchArtist, matchTitle, matchTrack].some(Boolean);
      });

      setFilteredAlbums(albumsFiltered);
    },
    [albums]
  );

  const numberOfAlbumsOnOneShelf =
    width < Number.parseInt(breakpointSize("max-width")) ? 2 : 4;

  const shelves = spliceArrayIntoChunks(albums, numberOfAlbumsOnOneShelf);

  const filteredAlbumsInChunks = spliceArrayIntoChunks(
    filteredAlbums,
    numberOfAlbumsOnOneShelf
  );

  return (
    <Page>
      <Head>
        <title>Vinyl Collection</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Menu>
        <MenuContent>
          <Logo>Vinyl Collection</Logo>
          <Filter
            onFilter={handleFilterAlbums}
            disabled={status !== "resolved"}
          />
        </MenuContent>
      </Menu>

      <Content>
        <Container>
          {
            {
              pending: spliceArrayIntoChunks(new Array(5).fill(null), 1).map(
                (_, i) => (
                  <AlbumShelf key={`shelf${i}`}>
                    <Fragment>
                      <Cover invisible />
                      <Shelf />
                    </Fragment>
                  </AlbumShelf>
                )
              ),
              resolved: shelves.map((_, i) => {
                const albumsOnShelf = filteredAlbumsInChunks?.[i] ?? [];

                return (
                  <AlbumShelf key={`shelf${i}`}>
                    {albumsOnShelf?.length > 0 ? (
                      albumsOnShelf.map((album, i) => (
                        <Fragment key={album.id}>
                          <Suspense fallback={<Cover invisible />}>
                            <Album album={album} />
                          </Suspense>
                          {i + 1 === albumsOnShelf.length && <Shelf />}
                        </Fragment>
                      ))
                    ) : (
                      <Fragment key={i}>
                        <Cover invisible />
                        <Shelf />
                      </Fragment>
                    )}
                  </AlbumShelf>
                );
              }),
              rejected: (
                <ErrorMessage>
                  Something went wrong when fetching albums
                </ErrorMessage>
              ),
            }[status]
          }
        </Container>
      </Content>
    </Page>
  );
}

export const getServerSideProps: GetServerSideProps<{
  syncCollection: boolean;
}> = async ({ query }) => ({
  props: {
    syncCollection: query.syncCollection !== undefined,
  },
});

function spliceArrayIntoChunks<T>(
  arr: Array<T>,
  size: number
): Array<Array<T>> {
  return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>
    arr.slice(i * size, i * size + size)
  );
}

function useWindowSize() {
  const isSSR = !globalThis.window;

  const [windowSize, setWindowSize] = useState({
    width: isSSR ? 1200 : window.innerWidth,
    height: isSSR ? 800 : window.innerHeight,
  });

  function changeWindowSize() {
    setWindowSize({ width: window.innerWidth, height: window.innerHeight });
  }

  useEffect(() => {
    window && window.addEventListener("resize", changeWindowSize);

    return () => {
      window && window.removeEventListener("resize", changeWindowSize);
    };
  }, []);

  return windowSize;
}

const Page = styled.div`
  background-color: var(--color-content);

  ${breakpoint("max-width")} {
    background-color: var(--color-background);
    padding: ${space(5)} 0 0 0;
  }
`;

const Content = styled.div`
  position: relative;
  overflow: hidden;
  height: 100%;
  width: 100%;
`;

const Menu = styled.div`
  width: 100%;
  position: sticky;
  top: 0;
  z-index: var(--zIndex-menu);
  background-color: var(--color-background);
`;

const MenuContent = styled.div`
  width: 100%;
  max-width: ${breakpointSize("max-width")};
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  margin: 0 auto;
  padding: ${space(3)} ${space(3)};
  background-color: var(--color-content);

  ${breakpoint(0)} {
    flex-direction: row;
    padding: ${space(4)} ${space(5)};
    align-items: center;
  }

  ${breakpoint("max-width")} {
    border-top-left-radius: ${space(4)};
    border-top-right-radius: ${space(4)};
  }
`;

const Container = styled.div`
  position: relative;
  display: flex;
  flex-direction: column;
  width: 100%;
  flex: 1;
  max-width: ${breakpointSize("max-width")};
  background-color: var(--color-content);
  margin: 0 0 0 ${fontSize(6)};
  padding-top: ${space(3)};

  ${breakpoint("max-width")} {
    margin: 0 auto;
    padding-top: ${space(5)};
  }
`;

const Logo = styled.span`
  font-weight: 700;
  font-size: ${fontSize(3)};
  text-transform: uppercase;
  margin-bottom: ${space(3)};

  ${breakpoint(0)} {
    margin-bottom: 0;
  }
`;

const AlbumShelf = styled.div`
  position: relative;
  float: left;
  display: flex;
  flex: 1;
  justify-content: space-around;
  margin-bottom: ${space(5)};
  padding-left: ${space(2)};
  padding-right: ${space(5)};

  ${breakpoint("max-width")} {
    margin-bottom: ${space(6)};
    padding-left: ${space(4)};
    padding-right: ${space(4)};
  }
`;

const Shelf = styled.div`
  border-bottom: ${fontSize(4)} solid #eae1d4;
  border-left: ${space(4)} solid transparent;
  border-right: ${space(4)} solid transparent;
  position: absolute;
  bottom: -${space(3)};
  left: -${space(4)};
  width: calc(100% + ${space(5)});
  z-index: var(--zIndex-shelf);

  &:after {
    content: "";
    background: var(--color-shelf-border);
    height: ${space(2)};
    width: calc(100% + ${space(5)});
    position: absolute;
    top: ${fontSize(4)};
    left: -${space(4)};
    right: 0;
    z-index: var(--zIndex-shelf-border);
    margin: 0;
    box-shadow: rgba(0, 0, 0, 0.7) 0px 10px 30px;

    ${breakpoint(0)} {
      height: ${fontSize(0)};
    }
  }
`;

const ErrorMessage = styled.p`
  color: var(--color-error);
  font-style: italic;
`;
